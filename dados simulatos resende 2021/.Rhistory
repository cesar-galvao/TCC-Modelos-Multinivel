data.frame("type"="area",envdat))
tpe$type<-as.factor(tpe$type)
tpe[,5:104]<-apply(tpe[,5:104],2,padr)
glimpse(tpe)
glimpse(data_fit_lmer)
glimpse(amb)
glimpse(tpe)
glimpse(phe)
glimpse(amb)
glimpse(familia)
glimpse(phe)
glimpse(feno)
read.table("envdat.txt") %>% glimpse()
glimpse(feno)
glimpse(phe)
glimpse(tpe)
View(tpe)
tpe <- read.table("envdat.txt") %>%
mutate(type = factor(
ifelse(!is.na(Trial),"phen", "area"))
)
glimpse(tpe)
envdat<-read.table("~/r_projects/curso_ambientomica/envdat.txt",header=TRUE)
dim(envdat) #10000 pixels * 100 covars
envdat[1:5,1:5]
View(envdat)
tpe <- read.table("envdat.txt") %>%
mutate(type = factor(
ifelse(!is.na(Trial),"phen", "area")), #cria a variavel type
across(starts_with("EA", ~ as.vector(scale(.)))) # padroniza as EA
) %>%
select(type, everything())
tpe <- read.table("envdat.txt") %>%
mutate(type = factor(
ifelse(!is.na(Trial),"phen", "area")), #cria a variavel type
across(starts_with("EA", ~ as.vector(scale(.)))) # padroniza as EA
) %>%
dplyr::select(type, everything())
tpe <- read.table("envdat.txt") %>%
mutate(type = factor(
ifelse(!is.na(Trial),"phen", "area")), #cria a variavel type
across(starts_with("EA"), ~ as.vector(scale(.))) # padroniza as EA
) %>%
dplyr::select(type, everything())
glimpse(tpe)
phe <- tpe %>%
filter(!is.na(Trial))
glimpse(feno)
phe <- tpe %>%
filter(!is.na(Trial)) %>%
dplyr::select(-type) %>%
inner_join(feno)
glimpse(phe)
fitness<-length(150)
glimpse(tpe)
ENVMkrs <- tpe %>% dplyr::select(type, Trial, Longitude, Latitude)
#lista de valores únicos de genótipo
genos <- phe$Genotype %>% unique()
#vetor vazio para aceitar os valores de fitness
fitness<-numeric(150)
#essa tabela receberá os marcadores ambientômicos
ENVMkrs <- tpe %>% dplyr::select(type, Trial, Longitude, Latitude)
#lista de valores únicos de genótipo
genos <- phe$Genotype %>% unique()
?sample
sample(2:10,1)
sample(2:10,1)
sample(2:10,1)
sample(2:10)
sample(genos,nsamp)
nsamp <- sample(2:10,1)
sample(genos,nsamp)
#subset contendo apenas os genotipos sorteados no passo anterior:
phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
nrow(boots)
nrow(boots)/2
sample(1:nrow(boots),nrow(boots)/2) %>%
sort()
glimpse(boots)
# dados das células que contém experimento
phe <- tpe %>%
filter(!is.na(Trial)) %>%
dplyr::select(-type) %>%
inner_join(feno) %>%
select(Genotype, Yield, Trial, Longitude, Latitude, everything())
# dados das células que contém experimento
phe <- tpe %>%
filter(!is.na(Trial)) %>%
dplyr::select(-type) %>%
inner_join(feno) %>%
dplyr::select(Genotype, Yield, Trial, Longitude, Latitude, everything())
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
glimpse(boots)
boots[poptr,c(2,6:105)]
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
boots[poptr,c(2,6:105)]
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness<-c(fitness,rgg)
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
i = 1
nsamp <- sample(2:10,1);nsamp #sorteando de 2 a 10 genotipos
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness<-c(fitness,rgg)
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
#Usando o modelo gerado do bootstrap, gerar previsões para todo o grid
#do TPE. Esse novo predict
ENVMkr <- predict(ENVfit,tpe[,-(1:4)])
paste("ENV",sprintf("%03d", 1:150),sep="")
paste("ENV",1:150,sep="")
?str_pad
ENVMkrs
#essa tabela receberá os marcadores ambientômicos
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(replicate(num_vectors, numeric(0)))
#essa tabela receberá os marcadores ambientômicos
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(replicate(150, numeric(0)))
rlang::last_trace()
#essa tabela receberá os marcadores ambientômicos
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(replicate(10000, numeric(0)))
View(ENVMkrs)
ENVMkrs <- bind_cols(
ENVMkrs,
as.data.frame(replicate(150, numeric(0)))
)
as.data.frame(replicate(150, numeric(0)))
?replicate
as.data.frame(replicate(150, numeric(0)))
replicate(2, numeric(2))
ENVMkrs <- bind_cols(
ENVMkrs,
as.data.frame(replicate(150, numeric(10000)))
)
#essa tabela receberá os marcadores ambientômicos
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude)
#essa tabela receberá os marcadores ambientômicos
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(as.data.frame(replicate(150, numeric(10000))))
glimpse(ENVMkrs)
?as.data.frame
#essa tabela receberá os marcadores ambientômicos
ENVnames<-paste("ENV",
str_pad(1:150, width = 3, side = "left", pad = "0"),
sep="")
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(
as.data.frame(replicate(150, numeric(10000)), col.names = ENVnames)
)
View(ENVMkrs)
#essa tabela receberá os marcadores ambientômicos
ENVnames<-paste("ENV",
str_pad(1:150, width = 3, side = "left", pad = "0"),
sep="")
ENVnames
as.data.frame(replicate(150, numeric(10000)), col.names = ENVnames
)
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(
as.data.frame(replicate(150, numeric(10000)), nm = ENVnames)
)
View(ENVMkrs)
as.data.frame(replicate(150, numeric(10000)), nm = ENVnames)
?data.frame
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(
as.data.frame(replicate(150, numeric(10000)), optional = ENVnames)
)
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(
as.data.frame(replicate(150, numeric(10000)), col.names = ENVnames)
)
View(ENVMkrs)
# Create a data frame with 10 empty numeric vectors and name the columns
num_vectors <- 10
column_names <- paste0("vec", 1:num_vectors)
empty_dataframe <- as.data.frame(replicate(num_vectors, numeric(0)), optional = column_names)
read.table(text = 0,
colClasses = replicate(150, numeric(10000)),
col.names = ENVnames)
read.table
?read.table
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(
as.data.frame(replicate(150, numeric(10000)), col.names = ENVnames)
)
names(ENVMkrs)
names(ENVMkrs)[-c(1:$)]
names(ENVMkrs)[-c(1:4)]
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(
#cria os vetores vazios para reservar memoria e acelerar o bootstrap
as.data.frame(replicate(150, numeric(10000)), col.names = ENVnames)
)
#renomeia as demais variaveis
names(ENVMkrs)[-c(1:4)]<-paste("ENV",
str_pad(1:150, width = 3, side = "left", pad = "0"),
sep="")
View(ENVMkrs)
ENVMkr
nsamp <- sample(2:10,1);nsamp #sorteando de 2 a 10 genotipos
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness<-c(fitness,rgg)
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
#Usando o modelo gerado do bootstrap, gerar previsões para todo o grid
#do TPE. Esse novo predict são os valores do marcador para todos os 10.000 pontos
ENVMkr <- predict(ENVfit,tpe[,-(1:4)])
ENVMkr
ENVMkrs <- tpe %>%
dplyr::select(type, Trial, Longitude, Latitude) %>%
mutate(
#cria os vetores vazios para reservar memoria e acelerar o bootstrap
as.data.frame(replicate(150, numeric(10000)), col.names = ENVnames)
)
#renomeia as demais variaveis
names(ENVMkrs)[-c(1:4)]<-paste("ENV",
str_pad(1:150, width = 3, side = "left", pad = "0"),
sep="")
#lista de valores únicos de genótipo
genos <- phe$Genotype %>% unique()
View(ENVMkrs)
### construcao dos ENVMRKR ----
for(i in 1:150){
#sorteando um número de amostras:
nsamp <- sample(2:10,1);nsamp #sorteando de 2 a 10 genotipos
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness<-c(fitness,rgg)
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
#Usando o modelo gerado do bootstrap, gerar previsões para todo o grid
#do TPE. Esse novo predict são os valores do marcador para todos os 10.000 pontos
ENVMkr <- predict(ENVfit,tpe[,-(1:4)])
ENVMkrs[,i+4] <- ENVMkr
}
View(ENVMkrs)
#rgg é considerado uma medida de goodness of fit
hist(fitness,breaks=50); abline(v=0,lty=2,lwd=3,col="red")
ENVMkrs[45:55,1:10]; dim(ENVMkrs) #conferida rapida
ENVMkrs[,ENVnames]<-apply(ENVMkrs[,ENVnames],2,padr)
# Selecao dos marcadores ambientomicos com rgg superior a 0.5
ENVsel<-names(fitness[fitness>0.5]);fitness[fitness>0.5]
ENVsel
fitness[fitness>0.5]
fitness
### construcao dos ENVMRKR ----
for(i in 1:150){
#sorteando um número de amostras:
nsamp <- sample(2:10,1);nsamp #sorteando de 2 a 10 genotipos
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness<-c(fitness,rgg)
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
#Usando o modelo gerado do bootstrap, gerar previsões para todo o grid
#do TPE. Esse novo predict são os valores do marcador para todos os 10.000 pontos
ENVMkr <- predict(ENVfit,tpe[,-(1:4)])
ENVMkrs[,i+4] <- ENVMkr
}
### construcao dos ENVMRKR ----
for(i in 1:150){
#sorteando um número de amostras:
nsamp <- sample(2:10,1);nsamp #sorteando de 2 a 10 genotipos
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness[i]<-rgg
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
#Usando o modelo gerado do bootstrap, gerar previsões para todo o grid
#do TPE. Esse novo predict são os valores do marcador para todos os 10.000 pontos
ENVMkr <- predict(ENVfit,tpe[,-(1:4)])
ENVMkrs[,i+4] <- ENVMkr
}
#vetor vazio para aceitar os valores de fitness
fitness<-numeric(150)
### construcao dos ENVMRKR ----
for(i in 1:150){
#sorteando um número de amostras:
nsamp <- sample(2:10,1);nsamp #sorteando de 2 a 10 genotipos
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness[i]<-rgg
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
#Usando o modelo gerado do bootstrap, gerar previsões para todo o grid
#do TPE. Esse novo predict são os valores do marcador para todos os 10.000 pontos
ENVMkr <- predict(ENVfit,tpe[,-(1:4)])
ENVMkrs[,i+4] <- ENVMkr
}
fitness[fitness>0.5]
names(fitness[fitness>0.5])
#rgg é considerado uma medida de goodness of fit
hist(fitness,breaks=50); abline(v=0,lty=2,lwd=3,col="red")
ENVMkrs[45:55,1:10]; dim(ENVMkrs) #conferida rapida
ENVMkrs[,ENVnames]<-apply(ENVMkrs[,ENVnames],2,padr)
names(fitness[fitness>0.5])
#vetor vazio para aceitar os valores de fitness
fitness<-numeric(150)
names(fitness)<-ENVnames
### construcao dos ENVMRKR ----
for(i in 1:150){
#sorteando um número de amostras:
nsamp <- sample(2:10,1);nsamp #sorteando de 2 a 10 genotipos
#subset contendo apenas os genotipos sorteados no passo anterior:
boots <- phe %>%
filter(Genotype %in% sample(genos,nsamp)) %>%
droplevels()
# montagem das amostras de treino e de validacao
poptr<-sample(1:nrow(boots),nrow(boots)/2) %>%
sort() #amostra de individuos com metade do tamanho do boot p/ treino
popvl<-(1:nrow(boots))[-poptr] #resto da amostra para validacao
# em dados de boots TREINO, usa amostra de treino e vars ambientais para treino
treino<-lm(Yield ~ ., data = droplevels(boots[poptr,c(2, #Yield
6:105)])) #EA
#rgg é a correlacao entre valores preditos na amostra na amostra de validacao e seus valores reais
rgg<-cor(
predict(treino,boots[popvl,c(2,6:105)]), #predict do modelo na particao de TREINO
boots[popvl,]$Yield)
fitness[i]<-rgg
#ENVFIT é um fit para todos os casos do bootstrap, sem dividir entre amostra de treino e val.
ENVfit<-lm(Yield ~ ., data=droplevels(boots[,c(2,6:105)]))
#R é a correlação entre os valores ajustados do ENVFIT e os valores reais do bootstrap
R<-cor(predict(ENVfit),boots$Yield)
##Ajuste não-linear:
#ENVfit<-randomForest(Yield ~ ., size=5,
#             data=droplevels(boots[,c(2,6:105)]))
#R<-cor(predict(ENVfit),boots$Yield);R
message("process= ",i,", nsamp= ",nsamp,", R= ",round(R,3),", rgg= ",round(rgg,3))
#Usando o modelo gerado do bootstrap, gerar previsões para todo o grid
#do TPE. Esse novo predict são os valores do marcador para todos os 10.000 pontos
ENVMkr <- predict(ENVfit,tpe[,-(1:4)])
# Atribui os valores do marcador à variavel correspondente
ENVMkrs[,i+4] <- ENVMkr
}
#rgg é considerado uma medida de goodness of fit
hist(fitness,breaks=50);
abline(v=0,lty=2,lwd=3,col="red")
#padroniza os marcadores ambientais
ENVMkrs[,ENVnames]<-apply(ENVMkrs[,ENVnames],2,padr)
names(fitness[fitness>0.5])
ENVMkrs[45:55,1:10]; dim(ENVMkrs) #conferida rapida
install.packages("foreach")
install.packages("doParallel")
??makeCluster
install.packages("parallely")
parallel::detectCores()
rm(list = ls())
